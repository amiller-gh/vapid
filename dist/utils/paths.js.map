{"version":3,"file":"paths.js","sourceRoot":"","sources":["../../lib/utils/paths.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from 'path';\nimport { IProvider } from '../Database/providers';\nimport { PageType } from '../Database/models/Template';\nimport { Record } from '../Database/models/Record';\n\nconst HTML_FILE_EXTS = { '': 1, '.html': 1 };\nconst SASS_FILE_EXTS = { '.scss': 1, '.sass': 1 };\n\n/**\n * Resolves commonly-used dashboard paths.\n * @return {Object} absolute paths\n */\nexport function getDashboardPaths() {\n  const paths = {\n    assets: path.resolve(__dirname, '../../assets'),\n    views: path.resolve(__dirname, '../../views'),\n  };\n\n  return paths;\n};\n\n/**\n * Validates that a given path is a valid asset path. HTML and s[c|a]ss files are excluded.\n * TODO: Its weird that this will return a string for the human readable error. Fix it.\n *\n * @param {string} path\n * @returns {boolean | string} Will return a string if there is a human readable error.\n */\nexport function isAssetPath(filePath: string) {\n  const ext = path.extname(filePath);\n\n  if (HTML_FILE_EXTS[ext] || filePath.match(/.pack\\.[js|scss|sass]/)) {\n    return false;\n  } else if (SASS_FILE_EXTS[ext]) {\n    const suggestion = filePath.replace(/\\.(scss|sass)$/, '.css');\n    return `Sass files cannot be served. Use \"${suggestion}\" instead.`;\n  }\n\n  return true;\n};\n\n\nexport async function getRecordFromPath(permalink: string, db: IProvider): Promise<Record | null> {\n\n  // Alias root requests.\n  if (permalink.endsWith('/')) { permalink = permalink.slice(0, -1); }\n  if (permalink === '' || permalink === '/') { permalink = 'index'; }\n\n  // If we have an exact match, opt for that.\n  const record = await db.getRecordBySlug(permalink);\n  if (record) { return record; }\n\n  // If a slug doesn't match perfectly, then any slashes in the name might come from a\n  // collection specifier. Parse this like a collection record.\n  if (permalink.includes('/')) {\n    const segments = permalink.split('/');\n    const collection = segments.shift();\n    const slug = segments.join('/');\n    const template = collection ? await db.getTemplateByName(collection, PageType.COLLECTION) : null;\n    if (!template) { return null; }\n\n    // Try to get the plain old slug value if it exists.\n    const record = await db.getRecordBySlug(`{${template.id}}${slug}`);\n    if (record) { return record; }\n\n    // Otherwise, this must be a {template_name}-{record_id} slug. Grab the ID.\n    const id = slug.split('-').pop();\n    return id ? await db.getRecordById(parseInt(id)) : null;\n  }\n\n  // Otherwise, this is a {template_name}-{record_id} slug for a page. Grab the ID.\n  const parts = permalink.split('-');\n  const id = parts.length > 1 ? parts.pop() : null;\n  return id ? await db.getRecordById(parseInt(id, 10)) : null;\n};\n"]}