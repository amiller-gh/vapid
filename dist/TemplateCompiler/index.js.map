{"version":3,"file":"index.js","sourceRoot":"","sources":["../../lib/TemplateCompiler/index.ts"],"names":[],"mappings":"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","sourcesContent":["// TODO: Clean this up. Lots of hacky stuff in here\nimport { readFileSync } from 'fs';\nimport { basename, dirname } from 'path';\nimport Boom from '@hapi/boom';\nimport Handlebars from 'handlebars';\nimport merge from 'lodash.merge';\nimport { SafeString } from 'handlebars';\n\nimport { Template, ITemplate, PageType, IField } from '../Database/models/Template';\n\nimport {\n  IAlias,\n  ParsedExpr,\n  NeutrinoHelper,\n  SectionHelper,\n  CollectionHelper,\n  IfHelper,\n  UnlessHelper,\n  CollateHelper,\n  EachHelper,\n  EqHelper,\n  MathHelper,\n  LinkHelper,\n  ImageHelper,\n  DateHelper,\n } from './helpers';\n\nimport { DATA_SYMBOL } from './constants';\n\ntype ASTNode = hbs.AST.BlockStatement\n  | hbs.AST.PartialStatement\n  | hbs.AST.PartialBlockStatement\n  | hbs.AST.DecoratorBlock\n  | hbs.AST.Decorator\n  | hbs.AST.MustacheStatement\n  | hbs.AST.ContentStatement\n  | hbs.AST.CommentStatement\n  | hbs.AST.SubExpression\n  | hbs.AST.PathExpression\n  | hbs.AST.StringLiteral\n  | hbs.AST.NumberLiteral\n  | hbs.AST.BooleanLiteral\n  | hbs.AST.Hash\n  | hbs.AST.Program\n  | hbs.AST.Expression\n  | hbs.AST.Statement;\n\ninterface IParsedTemplate {\n  name: string;\n  type: PageType;\n  data: Record<string, ITemplate>\n  ast: hbs.AST.Program,\n}\n\nfunction unwrap(func: (...args: any[]) => (string | SafeString)) {\n  return function helperWrapper(...args: Parameters<typeof func>) {\n    const values = [];\n    for (let arg of args) {\n      arg = (typeof arg === 'function') ? arg() : arg;\n      arg = (arg instanceof Handlebars.SafeString) ? arg.toString() : arg;\n      values.push(arg);\n    }\n    return func.apply(null, values);\n  };\n}\n\n/* eslint-enable no-param-reassign */\nfunction parseHash(hash: hbs.AST.Hash): Record<string, any> {\n  const out = {};\n  for (const pair of hash.pairs || []) {\n    out[pair.key] = pair.value.original;\n  }\n  return out;\n}\n\nfunction missingData(context: hbs.AST.BlockStatement | hbs.AST.SubExpression | hbs.AST.MustacheStatement) {\n  return (context.hash && context.hash.default) || `{{${context.path}}}`;\n}\n\n/**\n * TemplateCompiler class\n * Used in conjunction with a modified version of Mustache.js (Goatee)\n */\nexport class TemplateCompiler {\n\n  private Handlebars: typeof Handlebars;\n  private partials: Record<string, hbs.AST.Program>;\n  private rawPartials: Record<string, string> = {};\n  private helpers: Record<string, NeutrinoHelper> = {};\n\n  /**\n   * @param {object} partials – The partials to make available in this project.\n   * @param {array} helpers - Additional helpers to make available in this project.\n   */\n  constructor(partials: Record<string, hbs.AST.Program> = {}, helpers: Record<string, NeutrinoHelper> = {}) {\n    this.partials = partials;\n\n    // Set up our Handlebars instance.\n    // Vapid does not support the default helpers.\n    this.Handlebars = Handlebars.create();\n\n    // Register the ones we *do* support!\n    this.registerHelper('collection', CollectionHelper);\n    this.registerHelper('section', SectionHelper);\n\n    this.registerHelper('if', IfHelper);\n    this.registerHelper('unless', UnlessHelper);\n    this.registerHelper('collate', CollateHelper);\n    this.registerHelper('each', EachHelper);\n    this.registerHelper('eq', EqHelper);\n\n    this.registerHelper('math', MathHelper);\n\n    this.registerHelper('link', LinkHelper);\n    this.registerHelper('image', ImageHelper);\n    this.registerHelper('date', DateHelper);\n\n    // Special helper for logging missing data.\n    this.Handlebars.registerHelper('helperMissing', missingData);\n\n    // Register 3rd party helpers\n    for (const [name, helper] of Object.entries(helpers)) {\n      this.registerHelper(name, helper);\n    }\n  }\n\n  static get DATA_SYMBOL() { return DATA_SYMBOL; }\n\n  // Wrap all helpers so we unwrap function values and SafeStrings\n  registerHelper(name: string, helper: NeutrinoHelper) {\n    this.Handlebars.registerHelper(name, unwrap(helper.run));\n    this.helpers[name] = helper;\n  }\n\n  // Get if a given string is a registered helper name.\n  isHelper(name: string) {\n    return !!this.helpers[name];\n  }\n\n  /**\n   * Parses the HTML, and creates a template tree\n   *\n   * @return {Object} - a representation of the content\n   */\n  parse(name: string, type: PageType, html: string, data: Record<string, ITemplate> = {}, _aliases: Record<string, IAlias> = {}): IParsedTemplate {\n    let ast: hbs.AST.Program;\n    try {\n      ast = Handlebars.parse(html);\n    } catch (err) {\n      throw Boom.boomify(err, { message: 'Bad template syntax' });\n    }\n\n    if (type !== PageType.COMPONENT) {\n      /* eslint-disable-next-line no-param-reassign */\n      const template: ITemplate = {\n        name,\n        type,\n        options: {},\n        fields: {},\n        sortable: false,\n      };\n      data[Template.identifier(template)] = template;\n    }\n\n    this.walk(data, ast, {\n      '': { name: 'general', type: PageType.SETTINGS, isPrivate: false },\n      'this': { name, type, isPrivate: false },\n    });\n\n    return {\n      name,\n      type,\n      data,\n      ast,\n    };\n  }\n\n  /**\n   * Applies content to the template\n   *\n   * @param {Object} content\n   * @return {string} - HTML that has tags replaced with content\n   */\n  parseFile(filePath: string): IParsedTemplate {\n    const html = readFileSync(filePath, 'utf8');\n    const name = basename(filePath, '.html');\n    let type: PageType = PageType.PAGE;\n\n    if (dirname(filePath).endsWith('collections')) {\n      type = PageType.COLLECTION;\n    } else if (dirname(filePath).endsWith('components')) {\n      type = PageType.COMPONENT;\n    }\n\n    return this.parse(name, type, html);\n  }\n\n  /**\n   * Applies content to the template\n   *\n   * @param {Object} content\n   * @return {string} - HTML that has tags replaced with content\n   */\n  render(name: string, type: PageType, html: hbs.AST.Program, context = {}, data = {}) {\n    const ast = typeof html === 'string' ? this.parse(name, type, html) : html;\n    return this.Handlebars.compile(ast, { knownHelpersOnly: false, explicitPartialContext: false })(\n      context,\n      { data },\n    );\n  }\n\n  /**\n   * Applies content to the template\n   *\n   * @param {Object} content\n   * @return {string} - HTML that has tags replaced with content\n   */\n  renderFile(filePath: string, content = {}, data = {}) {\n    const { name, type, ast } = this.parseFile(filePath);\n    return this.render(name, type, ast, content, data);\n  }\n\n  /**\n   * @private\n   *\n   * Recursively walks Mustache tokens, and creates a tree that Vapid understands.\n   *\n   * @param {Object} tree - a memo that holds the total tree value\n   * @param {array} branch - Mustache tokens\n   * @return {Object} tree of sections, fields, params, etc.\n   */\n  /* eslint-disable no-param-reassign */\n  walk(data: Record<string, ITemplate>, node: ASTNode , aliases: Record<string, IAlias> = {}) {\n    \n    // Create a new copy of local aliases lookup object each time we enter a new block.\n    aliases = Object.create(aliases);\n\n    switch (node.type) {\n      case 'Program':\n        (node as hbs.AST.Program).body.forEach((n) => {\n          this.walk(data, n, aliases);\n        });\n        break;\n\n      // case 'DecoratorBlock': throw new Error('Vapid does not support Decorators.');\n      // case 'Decorator': throw new Error('Vapid does not support Decorators.');\n\n      case 'ContentStatement':\n        // TODO: Components?\n        break;\n\n      case 'PathExpression': {\n        const [leaf, path] = this.parseExpression(node);\n        leaf && path && addToTree(data, leaf, path, aliases);\n        break;\n      }\n\n      case 'MustacheStatement':\n      case 'SubExpression': {\n        // If this mustache has params, it must be a helper.\n        // Crawl all its params as potential data values.\n        if (node.params && node.params.length) {\n          for (const param of node.params) {\n            this.walk(data, param, aliases);\n          }\n\n        // Otherwise, this is a plain data value reference. Add it to the current object.\n        } else {\n          const [leaf, path] = this.parseExpression(node);\n          leaf && path && addToTree(data, leaf, path, aliases);\n        }\n        break;\n      }\n\n      case 'BlockStatement': {\n        // All Block statements are helpers. Grab the helper we're evaluating.\n        const helper = this.helpers[node.path.original];\n\n        // Crawl all its params as potential data values in scope.\n        if (node.params.length && !helper.isBranch) {\n          for (const param of node.params) {\n            this.walk(data, param, aliases);\n          }\n        }\n\n        // If this helper denotes the creation of a field, add it to the current model.\n        if (helper.isField) {\n          const [leaf, path] = this.parseExpression(node);\n          if (leaf && path) {\n            leaf.hash.type = helper.getType ? (helper.getType(leaf) || leaf.type) : leaf.type;\n            addToTree(data, leaf, path, aliases);\n          }\n        }\n\n        // If this helper denotes the creation of a new model type, ensure the model.\n        if (helper.isBranch) {\n          this.ensureBranch(data, node, helper);\n        }\n\n        // Assign any yielded block params to the aliases object.\n        node.program.blockParams = node.program.blockParams || [];\n        for (let idx = 0; idx < node.program.blockParams.length; idx += 1) {\n          const param = node.program.blockParams[idx];\n          aliases[param] = helper.blockParam(idx, node) || {\n            name: param,\n            type: PageType.SETTINGS,\n            isPrivate: true,\n          };\n        }\n\n        // Section tags change the `this` scope... This is special cased for now.\n        if (node.path.original === 'section') {\n          aliases[''] = {\n            name: node.params[0].original,\n            type: parseHash(node.hash).multiple === true ? PageType.COLLECTION : PageType.SETTINGS,\n            isPrivate: !!node.params[0].data,\n          };\n        }\n\n        if (node.program) this.walk(data, node.program, aliases);\n        if (node.inverse) this.walk(data, node.inverse, aliases);\n        break;\n      }\n\n      case 'PartialStatement':\n      case 'PartialBlockStatement':\n        // TODO: Ban partials?\n        if (this.rawPartials[node.name.original]) {\n          this.partials[node.name.original] = this.parse(\n            aliases.this.name,\n            aliases.this.type,\n            this.rawPartials[node.name.original],\n            data,\n            aliases,\n          ).ast;\n        }\n        if ((node as hbs.AST.PartialBlockStatement).program) this.walk(data, (node as hbs.AST.PartialBlockStatement).program, aliases);\n        break;\n\n      default: {\n        /*\n          Do nothing for:\n            - CommentStatement\n            - StringLiteral\n            - NumberLiteral\n            - BooleanLiteral\n            - UndefinedLiteral\n            - NullLiteral\n        */\n        break;\n      }\n    }\n\n    return data;\n  }\n\n  /* eslint-disable prefer-destructuring */\n  parseExpression(node:\n      hbs.AST.MustacheStatement\n    | hbs.AST.PathExpression\n    | hbs.AST.BlockStatement\n    | hbs.AST.MustacheStatement\n    | hbs.AST.SubExpression\n    | hbs.AST.Expression\n  ): [ParsedExpr | null, hbs.AST.PathExpression | hbs.AST.Literal | null] {\n    let path;\n    let hash: Record<string, any> | null;\n\n    switch (node.type) {\n      case 'PathExpression':\n        path = node;\n        hash = {};\n        break;\n      case 'BlockStatement':\n        path = this.parseExpression(node.params[0])[1];\n        hash = parseHash(node.hash);\n        break;\n      case 'MustacheStatement':\n      case 'SubExpression':\n        if (node.params.length) {\n          const tmp = this.parseExpression(node.params[0]);\n          path = tmp[1];\n          hash = tmp[0]?.hash || {};\n        } else {\n          path = node.path;\n          hash = parseHash(node.hash);\n        }\n        break;\n      default: {\n        return [null, null];\n      }\n    }\n\n    const context = path?.original.indexOf('this') === 0 ? 'this' : '';\n    const key = (path as hbs.AST.PathExpression).parts?.length === 1 ? (path as hbs.AST.PathExpression).parts[0] : (path as hbs.AST.PathExpression).parts.slice(1).join('.');\n\n    // TODO: Handle literal values\n    return [{\n      type: node.type,\n      original: path?.original || '',\n      key,\n      context: (path as hbs.AST.PathExpression)?.parts?.length === 1 ? context : (path as hbs.AST.PathExpression)?.parts?.[0],\n      path: path?.original || '',\n      parts: (path as hbs.AST.PathExpression)?.parts,\n      hash,\n      isPrivate: !!path?.data,\n    }, path];\n  }\n\n  ensureBranch(data: Record<string, ITemplate>, node: hbs.AST.BlockStatement | hbs.AST.DecoratorBlock, helper: NeutrinoHelper) {\n    const [expr] = this.parseExpression(node);\n\n    // If this is not an expression we care about, move on.\n    if (!expr) { return; }\n\n    // If this block is referencing a data property, don't add it to our data model.\n    if (node.params.length && (node.params[0].data || expr.isPrivate)) { return; }\n\n    // Record the type of this section appropriately\n    const name = expr.context || expr.key;\n    const newBranch: ITemplate = {\n      name,\n      type: helper.isBranch || PageType.PAGE,\n      options: expr.hash,\n      sortable: !!expr.hash.sortable,\n      fields: {},\n    };\n    const branch = data[Template.identifier(newBranch)] = data[Template.identifier(newBranch)] || newBranch;\n    merge(branch.options, newBranch.options);\n    merge(branch.fields, newBranch.fields);\n  }\n}\n\n/**\n * @private\n *\n * Parses a leaf token, and merges into the branch\n *\n * @params {string} leaf;\n * @params {string} path;\n * @params {string} tree;\n * @params {Object} aliases\n * @return {Object}\n */\nfunction addToTree(data: Record<string, ITemplate>, leaf: ParsedExpr, path: hbs.AST.PathExpression | hbs.AST.Literal, aliases: Record<string, IAlias>) {\n  // If this is a private path, no-op.\n  if (!leaf || leaf.isPrivate) { return data; }\n\n  // If this is a private section, no-op.\n  const isPrivateSection = aliases[leaf.context] ? aliases[leaf.context].isPrivate : false;\n  if (isPrivateSection) { return data; }\n\n  // If this is a private key, no-op.\n  const isPrivateKey = (!leaf.context && aliases[leaf.key]) ? aliases[leaf.key].isPrivate : false;\n  if (isPrivateKey) { return data; }\n\n  // Log a warning if we're referencing the default general context without an explicit reference.\n  // Update the original path node so we can actually render the template.\n  if (!leaf.context && !leaf.isPrivate && aliases[''] && aliases[''].name === 'general') {\n    console.warn(`[DEPRECATION] Referencing values without a context is deprecated. Found: {{${leaf.original}}}`);\n    leaf.context = 'general';\n    (path as hbs.AST.PathExpression).parts.unshift('general');\n    path.original = `general.${path.original}`;\n  }\n\n  // Get our section reference descriptor.\n  const name = (aliases[leaf.context] ? aliases[leaf.context].name : leaf.context) || 'general';\n  const type = (aliases[leaf.context] ? aliases[leaf.context].type : PageType.SETTINGS) || PageType.SETTINGS;\n\n  // Ensure the model object reference exists.\n  const template: ITemplate = {\n    sortable: false,\n    name,\n    type,\n    options: {},\n    fields: {},\n  };\n  const sectionKey = Template.identifier(template);\n  data[sectionKey] = data[sectionKey] || template;\n\n  // Ensure the field descriptor exists. Merge settings if already exists.\n  const old: IField | null = data[sectionKey].fields[leaf.key] || null;\n  data[sectionKey].fields[leaf.key] = {\n    key: leaf.key,\n    type: leaf.type || old?.type || 'text',\n    priority: leaf.hash.priority || old?.priority || 0,\n    label: leaf.hash.label || old?.label || '',\n    options: {...(old?.options || {}), ...leaf.hash },\n  }\n\n  return data;\n}\n"]}